import argparse
import clang
import clang.cindex
import contextlib
import numpy as np
import ctypes
import sys
import tempfile
import logging
from functools import partial
from typing import List, Union


PYBIND_DEF = """{ret_type} {pybind_name}({func_args}) {{
  check_nvshmem_init();
  return {name}({func_params});
}} """


PYI_FUNC_WITH_CUDASTREAM = """
def {pybind_name_wrapper}({arg_list_with_hint}) {return_type_hint}:
    return flux.pynvshmem_mod.{pybind_name}({params_no_stream})
"""

PYBIND_FUNC_IMPLS_HEADER = """
// DON'T EDIT THIS FILE. AUTOMATICALLY GENERATED BY autogen_pybind.py
#include <array>
#include <cstddef>
#include <nvshmemx.h>
#include <torch/all.h>
#include <vector>

namespace {
std::array<const char *, 5> kNvshmemInitStatus = {
    "NVSHMEM_STATUS_NOT_INITIALIZED",
    "NVSHMEM_STATUS_IS_BOOTSTRAPPED",
    "NVSHMEM_STATUS_IS_INITIALIZED",
    "NVSHMEM_STATUS_LIMITED_MPG",
    "NVSHMEM_STATUS_FULL_MPG"};
void
check_nvshmem_init() {
  CHECK(nvshmemx_init_status() >= NVSHMEM_STATUS_IS_INITIALIZED)
      << "nvshmem not initialized: status " << kNvshmemInitStatus[nvshmemx_init_status()];
}
}  // namespace

// clang-format off
"""

PYBIND_ADD_HEADER = """
// DON'T EDIT THIS FILE. AUTOMATICALLY GENERATED BY autogen_pybind.py
"""

PYI_HEADER = """# DON'T EDIT THIS FILE. AUTOMATICALLY GENERATED BY autogen_pybind.py
import ctypes
import torch
import numpy as np

# fmt: off
"""
PYWRAPPER_HEADER = """# DON'T EDIT THIS FILE. AUTOMATICALLY GENERATED BY autogen_pybind.py
import ctypes
import torch
import builtins
import numpy as np
from typing import Any, List, Sequence, Tuple, Union
import flux
from flux_ths_pybind._pynvshmem import *

from ._wrapper import *

# fmt: off
"""


def pretty_format(node):
    return "Found %s Type %s DATA %s Extent %s [line=%s, col=%s]" % (
        node.displayname,
        node.kind,
        node.data,
        node.extent,
        node.location.line,
        node.location.column,
    )


CLANG_TYPEKIND_MAPPING = {
    clang.cindex.TypeKind.POINTER: "ctypes.c_void_p",
    clang.cindex.TypeKind.BOOL: "np.bool",
    clang.cindex.TypeKind.CHAR_U: "np.uint8",
    clang.cindex.TypeKind.UCHAR: "np.uint8",
    clang.cindex.TypeKind.CHAR16: "np.int16",
    clang.cindex.TypeKind.CHAR32: "np.int32",
    clang.cindex.TypeKind.USHORT: "np.ushort",
    clang.cindex.TypeKind.UINT: "np.uintc",
    clang.cindex.TypeKind.ULONG: "np.uint",
    clang.cindex.TypeKind.ULONGLONG: "np.ulonglong",
    clang.cindex.TypeKind.UINT128: "np.uint128",
    clang.cindex.TypeKind.CHAR_S: "np.char",
    clang.cindex.TypeKind.SCHAR: "np.char",
    clang.cindex.TypeKind.SHORT: "np.short",
    clang.cindex.TypeKind.INT: "np.intc",
    clang.cindex.TypeKind.LONG: "np.int_",
    clang.cindex.TypeKind.LONGLONG: "np.longlong",
    clang.cindex.TypeKind.INT128: "np.int128",
    clang.cindex.TypeKind.FLOAT: "np.float32",
    clang.cindex.TypeKind.DOUBLE: "np.float64",
}


def rfind(string, pattern):
    for i in range(len(string) - 1, -1, -1):
        c = string[i]
        if c in pattern:
            return i
    return -1


class ClangFunction:
    def __init__(self, node: clang.cindex.Cursor) -> None:
        self.node = node
        self.arguments = list(node.get_arguments())
        self.param_names = [p.spelling for p in self.arguments]
        # fill in arg
        self.param_names = [name or f"arg{n}" for n, name in enumerate(self.param_names)]
        self.param_types = [p.type.spelling for p in self.arguments]
        try:
            self.hint_types = [
                CLANG_TYPEKIND_MAPPING[p.type.get_canonical().kind] for p in self.arguments
            ]
        except Exception as e:
            logging.debug(pretty_format(node))
            self.hint_types = None
        self.ret_type = node.type.get_result()
        self.ret_type_spelling = self.ret_type.spelling
        try:
            self.return_type_hint = (
                f" -> {CLANG_TYPEKIND_MAPPING[self.ret_type.kind]}"
                if self.ret_type.kind != clang.cindex.TypeKind.VOID
                else " -> None"
            )
        except Exception as e:
            self.return_type_hint = ""
            logging.debug(pretty_format(self.node))
        self.name = node.spelling

    @property
    def pybind_name(self):
        if self.name.endswith("_on_stream") or ["stream", "cstrm", "cstream"] in self.param_names:
            return f"_py{self.name}"
        return f"py{self.name}"

    @property
    def pybind_name_wrapper(self):
        return f"py{self.name}"

    def is_cuda_function(self):
        if self.node.spelling == "nvshmemx_barrier_all_warp":
            print(
                f"nvshmemx_barrier_all_warp: {list([t.spelling for t in self.node.get_tokens()])}"
            )
            print(
                any(
                    [
                        attr in [t.spelling for t in self.node.get_tokens()]
                        for attr in ["__device__", "__global__"]
                    ]
                )
            )
        return any(
            [
                attr in [t.spelling for t in self.node.get_tokens()]
                for attr in ["__device__", "__global__"]
            ]
        )

    def as_python_args(self):
        return [
            f"{arg_name}: {hint_type}"
            for (arg_name, hint_type) in zip(self.param_names, self.hint_types)
        ]

    def as_python_params(self):
        return [f"{arg_name}" for arg_name in self.param_names]

    def as_pyi(self):
        PYI_FUNC = "def {pybind_name}({arg_list_with_hint}) {return_type_hint}: ..."
        if self.hint_types is None:
            return
        return PYI_FUNC.format(
            pybind_name=self.pybind_name,
            arg_list_with_hint=", ".join(self.as_python_args()),
            return_type_hint=self.return_type_hint,
        )

    def cuda_stream_wrapper(self):
        if self.hint_types is None:
            return
        if self.pybind_name.endswith("_on_stream"):
            args = self.as_python_args()
            params = self.as_python_params()
            stream_wrapper = PYI_FUNC_WITH_CUDASTREAM.format(
                pybind_name_wrapper=self.pybind_name_wrapper,
                pybind_name=self.pybind_name,
                arg_list_with_hint=", ".join(args[:-1] + ["stream: CUDA_STREAM_TYPE"]),
                params_no_stream=", ".join(params[:-1] + ["_stream_raw(stream)"]),
                return_type_hint=self.return_type_hint,
            )
            return stream_wrapper

    def _is_cudaStream_argument(self, type, name):
        if self.node.spelling.endswith("_on_stream"):
            if name == self.param_names[-1]:
                if name not in ["stream", "cstrm", "cstream"]:
                    logging.warning(f"{self.node.spelling} has a stream argument at the end")
                return True
        if name in ["stream"] and type in ["cudaStream_t", "int"]:
            return True
        return False

    def _is_type_pointer(self, type, name):
        if name in ["source", "src", "dest"] and type.find("*") != -1:
            return True
        return False

    def as_cpp_arguments(self):
        def _to_argument(dtype, name):
            if self._is_cudaStream_argument(dtype, name):
                return f"intptr_t {name} /** {dtype} */"
            if self._is_type_pointer(dtype, name):
                return f"uintptr_t {name} /** {dtype} */"
            return f"{dtype} {name}"

        return ", ".join(
            [
                f"{_to_argument(dtype, name)}"
                for dtype, name in zip(self.param_types, self.param_names)
            ]
        )

    def as_cpp_params(self):
        def _to_param(dtype, name):
            if self._is_cudaStream_argument(dtype, name):
                return f"(cudaStream_t){name}"
            if self._is_type_pointer(dtype, name):
                return f"({dtype}){name}"
            return name

        return ", ".join(
            [f"{_to_param(dtype, name)}" for dtype, name in zip(self.param_types, self.param_names)]
        )


def _get_text_from_extent(extent):
    with open(extent.start.file.name, "r") as f:
        content = f.read()
    return content[extent.start.offset : extent.end.offset]


def get_nvshmem_nodes(node, types):
    def _visit(node, funcs):
        if node.kind in types:
            if node.spelling.startswith("nvshmem_") or node.spelling.startswith("nvshmemx_"):
                # print(pretty_format(node))
                funcs.append(node)

        for c in node.get_children():
            _visit(c, funcs)

    funcs = []
    _visit(node, funcs)
    return funcs


def filter_funcs(funcs):
    non_include_funcs = [
        # device functions
        "nvshmemx_signal_op",
        # not defined
        "nvshmem_realloc",
        "nvshmemx_init_thread",
        # c++ api
        "nvshmemx_n_pes",
        "nvshmemx_my_pe",
        "nvshmemi_align",
        # void** args
        "nvshmemx_collective_launch",
        "nvshmemx_collective_launch_query_gridsize",
        # internal functions
        "nvshmem_debug_log",
        "nvshmem_nvtx_print_options",
        "nvshmem_nvtx_set_thread_name",
        "nvshmem_nvtx_init",
        "nvshmemx_cumodule_init",
        "nvshmemx_cumodule_finalize",
    ]
    # device functions
    non_include_suffixes = ["_block", "_warp", "_alltoalls"]
    funcs = [f for f in funcs if not f.is_static_method()]
    func_names = set()
    funcs_dedup = []
    for func in funcs:
        if func.spelling in func_names:
            continue
        if func.spelling in non_include_funcs:
            continue
        if any([func.spelling.endswith(x) for x in non_include_suffixes]):
            continue
        funcs_dedup.append(func)
        func_names.add(func.spelling)
        logging.debug(func.spelling)
    return funcs_dedup


get_nvshmem_cudadevice = partial(get_nvshmem_nodes, types=[clang.cindex.CursorKind.CUDADEVICE_ATTR])

get_nvshmem_structs = partial(
    get_nvshmem_nodes,
    types=[clang.cindex.CursorKind.STRUCT_DECL, clang.cindex.CursorKind.CLASS_DECL],
)
get_nvshmem_enums = partial(get_nvshmem_nodes, types=[clang.cindex.CursorKind.ENUM_DECL])
get_nvshmem_funcs = partial(get_nvshmem_nodes, types=[clang.cindex.CursorKind.FUNCTION_DECL])


def autogen(nvshmem_home, output_dir):
    infile = f"{nvshmem_home}/src/host/comm/putget.cpp"
    logging.info(f"parsing {infile}")
    index = clang.cindex.Index.create()
    tu = index.parse(
        infile,
        args=compile_args,
        options=clang.cindex.TranslationUnit.PARSE_DETAILED_PROCESSING_RECORD,
    )

    structs = get_nvshmem_structs(tu.cursor)
    enums = get_nvshmem_enums(tu.cursor)
    logging.debug(f"structs: {[pretty_format(n) for n in structs]}")
    logging.debug(f"enums: {[pretty_format(n) for n in enums]}")

    pybind_func_impl_fout = open(f"{output_dir}/nvshmem_pybind_func_impls.cc.inc", "w")
    pybind_func_impl_fout.write(PYBIND_FUNC_IMPLS_HEADER)
    pybind_def_fout = open(f"{output_dir}/nvshmem_pybind_defs.cc.inc", "w")
    pyi_fout = open(f"{output_dir}/_pynvshmem.pyi", "w")
    pyi_fout.write(PYI_HEADER)
    py_wrapper_fout = open(f"{output_dir}/__init__.py", "w")
    py_wrapper_fout.write(PYWRAPPER_HEADER)

    funcs = get_nvshmem_funcs(tu.cursor)
    logging.info(f"{len(funcs)} functions found")
    funcs = filter_funcs(funcs)

    for func in funcs:
        func = ClangFunction(func)
        if func.is_cuda_function():
            continue
        pybind_def = PYBIND_DEF.format(
            ret_type=func.ret_type_spelling,
            pybind_name=func.pybind_name,
            func_args=func.as_cpp_arguments(),
            name=func.name,
            func_params=func.as_cpp_params(),
        )
        with contextlib.redirect_stdout(pybind_func_impl_fout):
            print(pybind_def)

        pybind_name = func.pybind_name
        pybind_add_func = f'pynvshmem_m.def("{pybind_name}", &{pybind_name});'
        with contextlib.redirect_stdout(pybind_def_fout):
            print(pybind_add_func)

        pyi_func = func.as_pyi()
        if pyi_func:
            with contextlib.redirect_stdout(pyi_fout):
                print(pyi_func)

        py_func_stream_wrapper = func.cuda_stream_wrapper()
        if py_func_stream_wrapper:
            with contextlib.redirect_stdout(py_wrapper_fout):
                print(py_func_stream_wrapper)

        import black
        from pathlib import Path

        black.format_file_in_place(
            Path(f"{output_dir}/_pynvshmem.pyi"),
            fast=True,
            mode=black.Mode(is_pyi=True),
            write_back=black.WriteBack.YES,
        )
        black.format_file_in_place(
            Path(f"{output_dir}/__init__.py"),
            fast=True,
            mode=black.Mode(is_pyi=True),
            write_back=black.WriteBack.YES,
        )


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--nvshmem_home")
    parser.add_argument("--output_dir", default="pynvshmem_autogen")
    return parser.parse_args()


if __name__ == "__main__":
    args = parse_args()
    logging.basicConfig(level=logging.INFO)
    nvshmem_home = args.nvshmem_home
    compile_args = [
        "-std=c++17",
        "-D_DEBUG",
        f"-I{nvshmem_home}/src/include",
    ]
    autogen(nvshmem_home, args.output_dir)
